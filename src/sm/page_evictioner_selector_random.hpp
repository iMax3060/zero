#ifndef __PAGE_EVICTIONER_SELECTOR_RANDOM_HPP
#define __PAGE_EVICTIONER_SELECTOR_RANDOM_HPP

#include "page_evictioner_selector.hpp"

#include <random>
#include <cstdlib>
#include <ctime>
#include <chrono>

namespace zero::buffer_pool {

    /*!\class   SeedGenerator
     * \brief   Seed generator for PRNGs
     * \details A seed generator for pseudorandom numbers generators that can be used as class template argument and
     *          called at runtime through its static member function \link getSeed() \endlink.
     */
    struct SeedGenerator {
    private:
        /*!\fn      SeedGenerator()
         * \brief   Defined to prevent instantiation of seed generators
         */
        SeedGenerator() {};
    };

    /*!\class   SeedGeneratorChrono
     * \brief   Seed generator using the wall-clock time for PRNGs
     * \details A seed generator for pseudorandom numbers generators that can be used as class template argument and
     *          called at runtime through its static member function \link getSeed() \endlink.
     *
     *          It uses the current wall-clock time for seed generation.
     *
     * @tparam seed_type The datatype of the seed generated by this (currently supported are \c uint32_t , \c uint64_t
     *                   and \c __uint128_t ).
     */
    template<typename seed_type>
    struct SeedGeneratorChrono : public SeedGenerator {
#if __SIZEOF_INT128__
        static_assert(std::is_same<seed_type, uint32_t>::value
                      || std::is_same<seed_type, uint64_t>::value
                      || std::is_same<seed_type, __uint128_t>::value, "'seed_type' is of unsupported type!");
#else // __SIZEOF_INT128__
        static_assert(std::is_same<seed_type, uint32_t>::value
                   || std::is_same<seed_type, uint64_t>::value, "'seed_type' is of unsupported type!");
#endif // __SIZEOF_INT128__

    private:
        /*!\fn      getSeed() noexcept
         * \brief   Defined to prevent call of this in generic class
         *
         * @return Nothing!
         */
        static seed_type getSeed() noexcept {};
    };

    /*!\class   SeedGeneratorChrono<uint32_t>
     * \brief   32-Bit seed generator using the wall-clock time for PRNGs
     * \details A seed generator for pseudorandom numbers generators that can be used as class template argument and
     *          called at runtime through its static member function \link getSeed() \endlink.
     *
     *          It uses the lower 32 bits of the current wall-clock time for seed generation.
     */
    template<>
    struct SeedGeneratorChrono<uint32_t> {
        /*!\fn      getSeed() noexcept
         * \brief   Returns the lower 32 bits of the current wall-clock time as seed
         *
         * @return The lower 32 bits of the current wall-clock time.
         */
        static inline uint32_t getSeed() noexcept {
            return static_cast<uint32_t>(chrono::high_resolution_clock::now().time_since_epoch().count());
        };
    };

    /*!\class   SeedGeneratorChrono<uint64_t>
     * \brief   64-Bit seed generator using the wall-clock time for PRNGs
     * \details A seed generator for pseudorandom numbers generators that can be used as class template argument and
     *          called at runtime through its static member function \link getSeed() \endlink.
     *
     *          It uses the current wall-clock time for seed generation.
     */
    template<>
    struct SeedGeneratorChrono<uint64_t> {
        /*!\fn      getSeed() noexcept
         * \brief   Returns the current wall-clock time as seed
         *
         * @return The current wall-clock time.
         */
        static inline uint64_t getSeed() noexcept {
            return static_cast<uint64_t>(chrono::high_resolution_clock::now().time_since_epoch().count());
        };
    };

#if __SIZEOF_INT128__
    /*!\class   SeedGeneratorChrono<__uint128_t>
     * \brief   128-Bit seed generator using the wall-clock time for PRNGs
     * \details A seed generator for pseudorandom numbers generators that can be used as class template argument and
     *          called at runtime through its static member function \link getSeed() \endlink.
     *
     *          It uses the current wall-clock time concatenated to the current wall-clock time for seed generation.
     *
     * \note    This specialization is only supported on systems with support for the datatype \c __uint128_t .
     */
    template<>
    struct SeedGeneratorChrono<__uint128_t> {
        /*!\fn      getSeed() noexcept
         * \brief   Returns the current wall-clock time concatenated to the current wall-clock time as seed
         *
         * @return The current wall-clock time concatenated to the current wall-clock time.
         */
        static inline __uint128_t getSeed() noexcept {
            return (static_cast<__uint128_t>(chrono::high_resolution_clock::now().time_since_epoch().count()) << 64)
                 + chrono::high_resolution_clock::now().time_since_epoch().count();
        };
    };
#endif // __SIZEOF_INT128__

    /*!\class   SeedGeneratorRandomDevice
     * \brief   Seed generator using a non-deterministic source for PRNGs
     * \details A seed generator for pseudorandom numbers generators that can be used as class template argument and
     *          called at runtime through its static member function \link getSeed() \endlink.
     *
     *          It uses the \c std::random_device provided by the C++ Standard Library.
     *
     * @tparam seed_type The datatype of the seed generated by this (currently supported are \c uint32_t , \c uint64_t
     *                   and \c __uint128_t ).
     */
    template<typename seed_type>
    struct SeedGeneratorRandomDevice : public SeedGenerator {
#if __SIZEOF_INT128__
        static_assert(std::is_same<seed_type, uint32_t>::value
                      || std::is_same<seed_type, uint64_t>::value
                      || std::is_same<seed_type, __uint128_t>::value, "'seed_type' is of unsupported type!");
#else // __SIZEOF_INT128__
        static_assert(std::is_same<seed_type, uint32_t>::value
                   || std::is_same<seed_type, uint64_t>::value, "'seed_type' is of unsupported type!");
#endif // __SIZEOF_INT128__

    private:
        /*!\fn      getSeed() noexcept
         * \brief   Defined to prevent call of this in generic class
         *
         * @return Nothing!
         */
        static seed_type getSeed() noexcept {};
    };

    /*!\class   SeedGeneratorRandomDevice<uint32_t>
     * \brief   32-Bit seed generator using a non-deterministic source for PRNGs
     * \details A seed generator for pseudorandom numbers generators that can be used as class template argument and
     *          called at runtime through its static member function \link getSeed() \endlink.
     *
     *          It uses the \c std::random_device provided by the C++ Standard Library.
     */
    template<>
    struct SeedGeneratorRandomDevice<uint32_t> {
        /*!\fn      getSeed() noexcept
         * \brief   Returns the a random number from the \c std::random_device as seed
         *
         * @return A random number from the \c std::random_device .
         */
        static inline uint32_t getSeed() noexcept {
            std::random_device randomDevice;

            return randomDevice();
        };
    };

    /*!\class   SeedGeneratorRandomDevice<uint64_t>
     * \brief   64-Bit seed generator using a non-deterministic source for PRNGs
     * \details A seed generator for pseudorandom numbers generators that can be used as class template argument and
     *          called at runtime through its static member function \link getSeed() \endlink.
     *
     *          It uses two random numbers generated using the \c std::random_device (provided by the C++ Standard
     *          Library) concatenated together.
     */
    template<>
    struct SeedGeneratorRandomDevice<uint64_t> {
        /*!\fn      getSeed() noexcept
         * \brief   Returns two random numbers from the \c std::random_device concatenated together as seed
         *
         * @return A two random numbers from the \c std::random_device concatenated together.
         */
        static inline uint64_t getSeed() noexcept {
            std::random_device randomDevice;

            return ((static_cast<uint64_t>(randomDevice()) << 32) | static_cast<uint64_t>(randomDevice()));
        };
    };

#if __SIZEOF_INT128__
    /*!\class   SeedGeneratorRandomDevice<__uint128_t>
     * \brief   128-Bit seed generator using a non-deterministic source for PRNGs
     * \details A seed generator for pseudorandom numbers generators that can be used as class template argument and
     *          called at runtime through its static member function \link getSeed() \endlink.
     *
     *          It uses four random numbers generated using the \c std::random_device (provided by the C++ Standard
     *          Library) concatenated together.
     *
     * \note    This specialization is only supported on systems with support for the datatype \c __uint128_t .
     */
    template<>
    struct SeedGeneratorRandomDevice<__uint128_t> {
        /*!\fn      getSeed() noexcept
         * \brief   Returns two random numbers from the \c std::random_device concatenated together as seed
         *
         * @return A four random numbers from the \c std::random_device concatenated together.
         */
        static inline __uint128_t getSeed() noexcept {
            std::random_device randomDevice;

            return (static_cast<__uint128_t>((static_cast<uint64_t>(randomDevice()) << 32) | static_cast<uint64_t>(randomDevice())) << 64)
                   + ((static_cast<uint64_t>(randomDevice()) << 32) | static_cast<uint64_t>(randomDevice()));
        };
    };
#endif // __SIZEOF_INT128__

    /*!\class   PageEvictionerSelectorRANDOMExternal
     * \brief   Global _RANDOM_ buffer frame selector that wraps an external PRNG
     * \details This is a buffer frame selector for the _Select-and-Filter_ page evictioner that implements the _RANDOM_
     *          policy. The _RANDOM_ policy selects buffer frames randomly.
     *
     *          This version of the _RANDOM_ policy acts as a wrapper for pseudorandom numbers generators implemented
     *          e.g. in a library. But this wrapper only supports PRNGs with the following minimal interface:
     *          - A [1] constructor without parameters (or with default arguments for all parameters) which seeds the
     *            PRNG with a default seed or a [2] constructor with \f$n\f$ seed parameters and no other parameters (or
     *            with default arguments for all other parameters).
     *          - The \c operator() function returns the next random number.
     *
     *          If the PRNG offers a [1] constructor, only the first template parameter has to be set. If it offers a
     *          [2] constructor, the second template parameter might be set.
     *
     *          Allowed specializations of this wrapper with exaple PRNGs:
     *          - The \c SamplePRNG can only be constructed calling \c SamplePRNG() where the seed is set in this
     *            constructor.
     *            - \c PageEvictionerSelectorRANDOMExternal<SamplePRNG>
     *          - The \c SamplePRNG does not offer a default seed and should only be constructed calling
     *            \c SamplePRNG(uint32_t) .
     *            - \c PageEvictionerSelectorRANDOMExternal<SamplePRNG, \c SeedGenerator<uint32_t>>
     *          - The \c SamplePRNG can be constructed calling either \c SamplePRNG() , \c SamplePRNG(uint32_t) or
     *            \c SamplePRNG(uint32_t, \c uint64_t) .
     *            - \c PageEvictionerSelectorRANDOMExternal<SamplePRNG>
     *            - \c PageEvictionerSelectorRANDOMExternal<SamplePRNG, \c SeedGenerator<uint32_t>>
     *            - \c PageEvictionerSelectorRANDOMExternal<SamplePRNG, \c SeedGenerator<uint32_t>,
     *              \c SeedGenerator<uint64_t>>
     *
     * \warning Each evicting thread uses the same instance of the PRNG without additional synchronization. If a PRNG
     *          does not support concurrent access, the \link PageEvictionerSelectorRANDOMExternalThreadLocal \endlink
     *          wrapper should be used.
     *
     * @tparam random_number_generator The pseudorandom numbers generator offering an interface supported by this
     *                                 wrapper.
     * @tparam random_distribution     The distribution of the generated random buffer frame indexes.
     * @tparam seed_generators         Seed generators derived from \link SeedGenerator \endlink and as supported by the
     *                                 PRNG set in the \c random_number_generator template parameter. See the class
     *                                 details for more information about this template parameter.
     */
    template<class random_number_generator, class random_distribution, class ... seed_generators>
    class PageEvictionerSelectorRANDOMExternal : public PageEvictionerSelector {
    public:
        /*!\fn      PageEvictionerSelectorRANDOMExternal(const BufferPool* bufferPool)
         * \brief   Constructs a _RANDOM_ buffer frame selector based on the set PRNG
         *
         * @param bufferPool The buffer pool this _RANDOM_ buffer frame selector is responsible for.
         */
        explicit PageEvictionerSelectorRANDOMExternal(const BufferPool* bufferPool) :
                PageEvictionerSelector(bufferPool),
                _randomNumberGenerator(seed_generators::getSeed() ...),
                _randomDistribution(1, _maxBufferpoolIndex) {};

        /*!\fn      select() noexcept
         * \brief   Selects a page to be evicted from the buffer pool
         * \details Selects a buffer frame randomly using the random numbers generator defined in the template parameter
         *          \c random_number_generator over a uniform distribution.
         *
         * @return The selected buffer frame.
         */
        inline bf_idx select() noexcept final {
            return static_cast<bf_idx>(_randomDistribution(_randomNumberGenerator));
        };

        /*!\fn      updateOnPageHit(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics on page hit
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink on which a page hit occurred.
         */
        inline void updateOnPageHit(bf_idx idx) noexcept final {};

        /*!\fn      updateOnPageUnfix(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics on page unfix
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink on which a page unfix occurred.
         */
        inline void updateOnPageUnfix(bf_idx idx) noexcept final {};

        /*!\fn      updateOnPageMiss(bf_idx idx, PageID pid) noexcept
         * \brief   Updates the eviction statistics on page miss
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink on which a page miss occurred.
         * @param pid The \link PageID \endlink of the \link generic_page \endlink that was loaded into the buffer
         *             frame with index \c idx .
         */
        inline void updateOnPageMiss(bf_idx idx, PageID pid) noexcept final {};

        /*!\fn      updateOnPageFixed(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics of fixed (i.e. used) pages during eviction
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink that was picked for eviction while the
         *            corresponding frame was fixed.
         */
        inline void updateOnPageFixed(bf_idx idx) noexcept final {};

        /*!\fn      updateOnPageDirty(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics of dirty pages during eviction
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink that was picked for eviction while the
         *            corresponding frame contained a dirty page.
         */
        inline void updateOnPageDirty(bf_idx idx) noexcept final {};

        /*!\fn      updateOnPageBlocked(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics of pages that cannot be evicted at all
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink which corresponding frame contains a page
         *            that cannot be evicted at all.
         */
        inline void updateOnPageBlocked(bf_idx idx) noexcept final {};

        /*!\fn      updateOnPageSwizzled(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics of pages containing swizzled pointers during eviction
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink that was picked for eviction while the
         *            corresponding frame contained a page with swizzled pointers.
         */
        inline void updateOnPageSwizzled(bf_idx idx) noexcept final {};

        /*!\fn      updateOnPageExplicitlyUnbuffered(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics on explicit unbuffer
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink whose corresponding frame is freed
         *            explicitly.
         */
        inline void updateOnPageExplicitlyUnbuffered(bf_idx idx) noexcept final {};

        /*!\fn      releaseInternalLatches() noexcept
         * \brief   Releases the internal latches of this buffer frame selector
         * \details This buffer frame selector does not use locking and therefore this function does nothing.
         */
        inline void releaseInternalLatches() noexcept final {};

    private:
        /*!\var     _standardRandomEngine
         * \brief   The used pseudo-random number generator
         */
        random_number_generator _randomNumberGenerator;

        /*!\var     _randomDistribution
         * \brief   The uniform distribution and range for the pseudo-random number generator (post-processor)
         */
        random_distribution _randomDistribution;

    };

    /*!\class   PageEvictionerSelectorRANDOMExternalThreadLocal
     * \brief   _RANDOM_ buffer frame selector that wraps an external PRNG
     * \details This is a buffer frame selector for the _Select-and-Filter_ page evictioner that implements the _RANDOM_
     *          policy. The _RANDOM_ policy selects buffer frames randomly.
     *
     *          This version of the _RANDOM_ policy acts as a wrapper for pseudorandom numbers generators implemented
     *          e.g. in a library. But this wrapper only supports PRNGs with the following minimal interface:
     *          - A [1] constructor without parameters (or with default arguments for all parameters) which seeds the
     *            PRNG with a default seed or a [2] constructor with \f$n\f$ seed parameters and no other parameters (or
     *            with default arguments for all other parameters).
     *          - The \c operator() function returns the next random number.
     *
     *          If the PRNG offers a [1] constructor, the \c seed_explicitly template parameter can be set to \c false
     *          and the \c seed_generators does not to be set. If it offers a [2] constructor, the \c seed_explicitly
     *          template parameter can be set to \c true and therefore the \c seed_generators need to be set properly.
     *
     *          Allowed specializations of this wrapper with exaple PRNGs:
     *          - The \c SamplePRNG can only be constructed calling \c SamplePRNG() where the seed is set in this
     *            constructor.
     *            - \c PageEvictionerSelectorRANDOMExternal<SamplePRNG, false>
     *          - The \c SamplePRNG does not offer a default seed and should only be constructed calling
     *            \c SamplePRNG(uint32_t) .
     *            - \c PageEvictionerSelectorRANDOMExternal<SamplePRNG, true, \c SeedGenerator<uint32_t>>
     *          - The \c SamplePRNG can be constructed calling either \c SamplePRNG() , \c SamplePRNG(uint32_t) or
     *            \c SamplePRNG(uint32_t, \c uint64_t) .
     *            - \c PageEvictionerSelectorRANDOMExternal<SamplePRNG>
     *            - \c PageEvictionerSelectorRANDOMExternal<SamplePRNG, true, \c SeedGenerator<uint32_t>>
     *            - \c PageEvictionerSelectorRANDOMExternal<SamplePRNG, true, \c SeedGenerator<uint32_t>,
     *              \c SeedGenerator<uint64_t>>
     *
     * \note    This thread uses one instance of the PRNG per evicting thread. If a default seed for the PRNG is used,
     *          the same seed is used for all instances, otherwise, all the instances are seeded differently.
     *
     * @tparam random_number_generator The pseudorandom numbers generator offering an interface supported by this
     *                                 wrapper.
     * @tparam random_distribution     The distribution of the generated random buffer frame indexes.
     * @tparam seed_explicitly         If \c true , the PRNG is seeded using the seed generators from \c seed_generators
     *                                 , otherwise the PRNG is seeded with its default seed.
     * @tparam seed_generators         Seed generators derived from \link SeedGenerator \endlink and as supported by the
     *                                 PRNG set in the \c random_number_generator template parameter. See the class
     *                                 details for more information about this template parameter.
     */
    template<class random_number_generator, class random_distribution, bool seed_explicitly, class ... seed_generators>
    class PageEvictionerSelectorRANDOMExternalThreadLocal : public PageEvictionerSelector {
    public:
        /*!\fn      PageEvictionerSelectorRANDOMExternalThreadLocal(const BufferPool* bufferPool)
         * \brief   Constructs a _RANDOM_ buffer frame selector based on the set PRNG
         *
         * @param bufferPool The buffer pool this _RANDOM_ buffer frame selector is responsible for.
         */
        explicit PageEvictionerSelectorRANDOMExternalThreadLocal(const BufferPool* bufferPool) :
                PageEvictionerSelector(bufferPool),
                _randomDistribution(1, _maxBufferpoolIndex) {};

        /*!\fn      select() noexcept
         * \brief   Selects a page to be evicted from the buffer pool
         * \details Selects a buffer frame randomly using the random numbers generator defined in the template parameter
         *          \c random_number_generator over a uniform distribution.
         *
         * @return The selected buffer frame.
         */
        inline bf_idx select() noexcept final {

            /*!\var     _randomNumberGeneratorInitialized
             * \brief   Is the PRNG already seeded in this thread?
             */
            static thread_local bool _randomNumberGeneratorInitialized;

            /*!\var     _standardRandomEngine
             * \brief   The used pseudo-random number generator
             */
            static thread_local random_number_generator _randomNumberGenerator;

            if constexpr (seed_explicitly) {
                if (!_randomNumberGeneratorInitialized) {
                    _randomNumberGenerator = random_number_generator(seed_generators::getSeed() ...);
                    _randomNumberGeneratorInitialized = true;
                }
            }

            return static_cast<bf_idx>(_randomDistribution(_randomNumberGenerator));
        };

        /*!\fn      updateOnPageHit(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics on page hit
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink on which a page hit occurred.
         */
        inline void updateOnPageHit(bf_idx idx) noexcept final {};

        /*!\fn      updateOnPageUnfix(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics on page unfix
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink on which a page unfix occurred.
         */
        inline void updateOnPageUnfix(bf_idx idx) noexcept final {};

        /*!\fn      updateOnPageMiss(bf_idx idx, PageID pid) noexcept
         * \brief   Updates the eviction statistics on page miss
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink on which a page miss occurred.
         * @param pid The \link PageID \endlink of the \link generic_page \endlink that was loaded into the buffer
         *             frame with index \c idx .
         */
        inline void updateOnPageMiss(bf_idx idx, PageID pid) noexcept final {};

        /*!\fn      updateOnPageFixed(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics of fixed (i.e. used) pages during eviction
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink that was picked for eviction while the
         *            corresponding frame was fixed.
         */
        inline void updateOnPageFixed(bf_idx idx) noexcept final {};

        /*!\fn      updateOnPageDirty(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics of dirty pages during eviction
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink that was picked for eviction while the
         *            corresponding frame contained a dirty page.
         */
        inline void updateOnPageDirty(bf_idx idx) noexcept final {};

        /*!\fn      updateOnPageBlocked(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics of pages that cannot be evicted at all
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink which corresponding frame contains a page
         *            that cannot be evicted at all.
         */
        inline void updateOnPageBlocked(bf_idx idx) noexcept final {};

        /*!\fn      updateOnPageSwizzled(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics of pages containing swizzled pointers during eviction
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink that was picked for eviction while the
         *            corresponding frame contained a page with swizzled pointers.
         */
        inline void updateOnPageSwizzled(bf_idx idx) noexcept final {};

        /*!\fn      updateOnPageExplicitlyUnbuffered(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics on explicit unbuffer
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink whose corresponding frame is freed
         *            explicitly.
         */
        inline void updateOnPageExplicitlyUnbuffered(bf_idx idx) noexcept final {};

        /*!\fn      releaseInternalLatches() noexcept
         * \brief   Releases the internal latches of this buffer frame selector
         * \details This buffer frame selector does not use locking and therefore this function does nothing.
         */
        inline void releaseInternalLatches() noexcept final {};

    private:
        /*!\var     _randomDistribution
         * \brief   The uniform distribution and range for the pseudo-random number generator (post-processor)
         */
        std::uniform_int_distribution<bf_idx> _randomDistribution;

    };

    /*!\class   PageEvictionerSelectorRANDOMCLHEP
     * \brief   Global _RANDOM_ buffer frame selector that wraps an CLHEP PRNG
     * \details This is a buffer frame selector for the _Select-and-Filter_ page evictioner that implements the _RANDOM_
     *          policy. The _RANDOM_ policy selects buffer frames randomly.
     *
     *          This version of the _RANDOM_ policy acts as a wrapper for pseudorandom numbers generators implemented
     *          in the \e Class \e Library \e for \e High \e Energy \e Physics.
     *
     * \warning Each evicting thread uses the same instance of the PRNG without additional synchronization. If a PRNG
     *          does not support concurrent access, the \link PageEvictionerSelectorRANDOMExternalThreadLocal \endlink
     *          wrapper should be used.
     *
     * @tparam random_number_generator A pseudorandom numbers generator from the CLHEP.
     * @tparam seed_generators         Seed generators derived from \link SeedGenerator \endlink and as supported by the
     *                                 PRNG set in the \c random_number_generator template parameter. See the class
     *                                 details for more information about this template parameter.
     */
    template<class random_number_generator, class ... seed_generators>
    class PageEvictionerSelectorRANDOMCLHEP : public PageEvictionerSelector {
    public:
        /*!\fn      PageEvictionerSelectorRANDOMCLHEP(const BufferPool* bufferPool)
         * \brief   Constructs a _RANDOM_ buffer frame selector based on the set PRNG from CLHEP
         *
         * @param bufferPool The buffer pool this _RANDOM_ buffer frame selector is responsible for.
         */
        explicit PageEvictionerSelectorRANDOMCLHEP(const BufferPool* bufferPool) :
                PageEvictionerSelector(bufferPool),
                _randomNumberGenerator(seed_generators::getSeed() ...) {};

        /*!\fn      select() noexcept
         * \brief   Selects a page to be evicted from the buffer pool
         * \details Selects a buffer frame randomly using the random numbers generator defined in the template parameter
         *          \c random_number_generator over a uniform distribution.
         *
         * @return The selected buffer frame.
         */
        inline bf_idx select() noexcept final {
            return static_cast<uint32_t>(((uint32_t(_randomNumberGenerator)) % (_maxBufferpoolIndex - 1) + 1));
        };

        /*!\fn      updateOnPageHit(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics on page hit
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink on which a page hit occurred.
         */
        inline void updateOnPageHit(bf_idx idx) noexcept final {};

        /*!\fn      updateOnPageUnfix(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics on page unfix
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink on which a page unfix occurred.
         */
        inline void updateOnPageUnfix(bf_idx idx) noexcept final {};

        /*!\fn      updateOnPageMiss(bf_idx idx, PageID pid) noexcept
         * \brief   Updates the eviction statistics on page miss
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink on which a page miss occurred.
         * @param pid The \link PageID \endlink of the \link generic_page \endlink that was loaded into the buffer
         *             frame with index \c idx .
         */
        inline void updateOnPageMiss(bf_idx idx, PageID pid) noexcept final {};

        /*!\fn      updateOnPageFixed(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics of fixed (i.e. used) pages during eviction
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink that was picked for eviction while the
         *            corresponding frame was fixed.
         */
        inline void updateOnPageFixed(bf_idx idx) noexcept final {};

        /*!\fn      updateOnPageDirty(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics of dirty pages during eviction
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink that was picked for eviction while the
         *            corresponding frame contained a dirty page.
         */
        inline void updateOnPageDirty(bf_idx idx) noexcept final {};

        /*!\fn      updateOnPageBlocked(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics of pages that cannot be evicted at all
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink which corresponding frame contains a page
         *            that cannot be evicted at all.
         */
        inline void updateOnPageBlocked(bf_idx idx) noexcept final {};

        /*!\fn      updateOnPageSwizzled(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics of pages containing swizzled pointers during eviction
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink that was picked for eviction while the
         *            corresponding frame contained a page with swizzled pointers.
         */
        inline void updateOnPageSwizzled(bf_idx idx) noexcept final {};

        /*!\fn      updateOnPageExplicitlyUnbuffered(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics on explicit unbuffer
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink whose corresponding frame is freed
         *            explicitly.
         */
        inline void updateOnPageExplicitlyUnbuffered(bf_idx idx) noexcept final {};

        /*!\fn      releaseInternalLatches() noexcept
         * \brief   Releases the internal latches of this buffer frame selector
         * \details This buffer frame selector does not use locking and therefore this function does nothing.
         */
        inline void releaseInternalLatches() noexcept final {};

    private:
        /*!\var     _standardRandomEngine
         * \brief   The used pseudo-random number generator
         */
        random_number_generator _randomNumberGenerator;

    };

    /*!\class   PageEvictionerSelectorRANDOMCLHEPThreadLocal
     * \brief   _RANDOM_ buffer frame selector that wraps an CLHEP PRNG
     * \details This is a buffer frame selector for the _Select-and-Filter_ page evictioner that implements the _RANDOM_
     *          policy. The _RANDOM_ policy selects buffer frames randomly.
     *
     *          This version of the _RANDOM_ policy acts as a wrapper for pseudorandom numbers generators implemented
     *          in the \e Class \e Library \e for \e High \e Energy \e Physics.
     *
     * \note    This thread uses one instance of the PRNG per evicting thread. If a default seed for the PRNG is used,
     *          the same seed is used for all instances, otherwise, all the instances are seeded differently.
     *
     * @tparam random_number_generator A pseudorandom numbers generator from the CLHEP.
     * @tparam seed_explicitly         If \c true , the PRNG is seeded using the seed generators from \c seed_generators
     *                                 , otherwise the PRNG is seeded with its default seed.
     * @tparam seed_generators         Seed generators derived from \link SeedGenerator \endlink and as supported by the
     *                                 PRNG set in the \c random_number_generator template parameter. See the class
     *                                 details for more information about this template parameter.
     */
    template<class random_number_generator, bool seed_explicitly, class ... seed_generators>
    class PageEvictionerSelectorRANDOMCLHEPThreadLocal : public PageEvictionerSelector {
    public:
        /*!\fn      PageEvictionerSelectorRANDOMCLHEPThreadLocal(const BufferPool* bufferPool)
         * \brief   Constructs a _RANDOM_ buffer frame selector based on the set PRNG from CLHEP
         *
         * @param bufferPool The buffer pool this _RANDOM_ buffer frame selector is responsible for.
         */
        explicit PageEvictionerSelectorRANDOMCLHEPThreadLocal(const BufferPool* bufferPool) :
                PageEvictionerSelector(bufferPool) {};

        /*!\fn      select() noexcept
         * \brief   Selects a page to be evicted from the buffer pool
         * \details Selects a buffer frame randomly using the random numbers generator defined in the template parameter
         *          \c random_number_generator over a uniform distribution.
         *
         * @return The selected buffer frame.
         */
        inline bf_idx select() noexcept final {

            /*!\var     _randomNumberGeneratorInitialized
             * \brief   Is the PRNG already seeded in this thread?
             */
            static thread_local bool _randomNumberGeneratorInitialized;

            /*!\var     _standardRandomEngine
             * \brief   The used pseudo-random number generator
             */
            static thread_local random_number_generator _randomNumberGenerator;

            if constexpr (seed_explicitly) {
                if (!_randomNumberGeneratorInitialized) {
                    _randomNumberGenerator = random_number_generator(seed_generators::getSeed() ...);
                    _randomNumberGeneratorInitialized = true;
                }
            }

            return static_cast<uint32_t>(((uint32_t(_randomNumberGenerator)) % (_maxBufferpoolIndex - 1) + 1));
        };

        /*!\fn      updateOnPageHit(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics on page hit
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink on which a page hit occurred.
         */
        inline void updateOnPageHit(bf_idx idx) noexcept final {};

        /*!\fn      updateOnPageUnfix(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics on page unfix
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink on which a page unfix occurred.
         */
        inline void updateOnPageUnfix(bf_idx idx) noexcept final {};

        /*!\fn      updateOnPageMiss(bf_idx idx, PageID pid) noexcept
         * \brief   Updates the eviction statistics on page miss
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink on which a page miss occurred.
         * @param pid The \link PageID \endlink of the \link generic_page \endlink that was loaded into the buffer
         *             frame with index \c idx .
         */
        inline void updateOnPageMiss(bf_idx idx, PageID pid) noexcept final {};

        /*!\fn      updateOnPageFixed(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics of fixed (i.e. used) pages during eviction
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink that was picked for eviction while the
         *            corresponding frame was fixed.
         */
        inline void updateOnPageFixed(bf_idx idx) noexcept final {};

        /*!\fn      updateOnPageDirty(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics of dirty pages during eviction
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink that was picked for eviction while the
         *            corresponding frame contained a dirty page.
         */
        inline void updateOnPageDirty(bf_idx idx) noexcept final {};

        /*!\fn      updateOnPageBlocked(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics of pages that cannot be evicted at all
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink which corresponding frame contains a page
         *            that cannot be evicted at all.
         */
        inline void updateOnPageBlocked(bf_idx idx) noexcept final {};

        /*!\fn      updateOnPageSwizzled(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics of pages containing swizzled pointers during eviction
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink that was picked for eviction while the
         *            corresponding frame contained a page with swizzled pointers.
         */
        inline void updateOnPageSwizzled(bf_idx idx) noexcept final {};

        /*!\fn      updateOnPageExplicitlyUnbuffered(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics on explicit unbuffer
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink whose corresponding frame is freed
         *            explicitly.
         */
        inline void updateOnPageExplicitlyUnbuffered(bf_idx idx) noexcept final {};

        /*!\fn      releaseInternalLatches() noexcept
         * \brief   Releases the internal latches of this buffer frame selector
         * \details This buffer frame selector does not use locking and therefore this function does nothing.
         */
        inline void releaseInternalLatches() noexcept final {};

    };

    /*!\class   PageEvictionerSelectorRANDOMCRand
     * \brief   _RANDOM_ buffer frame selector
     * \details This is a buffer frame selector for the _Select-and-Filter_ page evictioner that implements the _RANDOM_
     *          policy. The _RANDOM_ policy selects buffer frames randomly. This version of the _RANDOM_ policy uses
     *          the \c std::rand random number generator of the C Standard Library.
     */
    class PageEvictionerSelectorRANDOMCRand : public PageEvictionerSelector {
    public:
        /*!\fn      PageEvictionerSelectorRANDOMCRand(const BufferPool* bufferPool)
         * \brief   Constructs a _RANDOM_ buffer frame selector
         *
         * @param bufferPool The buffer pool this _RANDOM_ buffer frame selector is responsible for.
         */
        explicit PageEvictionerSelectorRANDOMCRand(const BufferPool* bufferPool) :
                PageEvictionerSelector(bufferPool) {
            std::srand(std::time(nullptr));
        };

        /*!\fn      select() noexcept
         * \brief   Selects a page to be evicted from the buffer pool
         * \details Selects a buffer frame randomly using the \c std::rand random number generator of the C Standard
         *          Library.
         *
         * @return The selected buffer frame.
         */
        inline bf_idx select() noexcept final {
            return 1 + std::rand() / ((RAND_MAX + 1u) / _maxBufferpoolIndex);
        };

        /*!\fn      updateOnPageHit(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics on page hit
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink on which a page hit occurred.
         */
        inline void updateOnPageHit(bf_idx idx) noexcept final {};

        /*!\fn      updateOnPageUnfix(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics on page unfix
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink on which a page unfix occurred.
         */
        inline void updateOnPageUnfix(bf_idx idx) noexcept final {};

        /*!\fn      updateOnPageMiss(bf_idx idx, PageID pid) noexcept
         * \brief   Updates the eviction statistics on page miss
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink on which a page miss occurred.
         * @param pid The \link PageID \endlink of the \link generic_page \endlink that was loaded into the buffer
         *             frame with index \c idx .
         */
        inline void updateOnPageMiss(bf_idx idx, PageID pid) noexcept final {};

        /*!\fn      updateOnPageFixed(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics of fixed (i.e. used) pages during eviction
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink that was picked for eviction while the
         *            corresponding frame was fixed.
         */
        inline void updateOnPageFixed(bf_idx idx) noexcept final {};

        /*!\fn      updateOnPageDirty(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics of dirty pages during eviction
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink that was picked for eviction while the
         *            corresponding frame contained a dirty page.
         */
        inline void updateOnPageDirty(bf_idx idx) noexcept final {};

        /*!\fn      updateOnPageBlocked(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics of pages that cannot be evicted at all
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink which corresponding frame contains a page
         *            that cannot be evicted at all.
         */
        inline void updateOnPageBlocked(bf_idx idx) noexcept final {};

        /*!\fn      updateOnPageSwizzled(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics of pages containing swizzled pointers during eviction
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink that was picked for eviction while the
         *            corresponding frame contained a page with swizzled pointers.
         */
        inline void updateOnPageSwizzled(bf_idx idx) noexcept final {};

        /*!\fn      updateOnPageExplicitlyUnbuffered(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics on explicit unbuffer
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink whose corresponding frame is freed
         *            explicitly.
         */
        inline void updateOnPageExplicitlyUnbuffered(bf_idx idx) noexcept final {};

        /*!\fn      releaseInternalLatches() noexcept
         * \brief   Releases the internal latches of this buffer frame selector
         * \details This buffer frame selector does not use locking and therefore this function does nothing.
         */
        inline void releaseInternalLatches() noexcept final {};

    };

    /*!\class   PageEvictionerSelectorRANDOMXORWow
     * \brief   _RANDOM_ buffer frame selector
     * \details This is a buffer frame selector for the _Select-and-Filter_ page evictioner that implements the _RANDOM_
     *          policy. The _RANDOM_ policy selects buffer frames randomly. This version of the _RANDOM_ policy uses
     *          uses a Xorwow pseudo-random number generator and a 192-bit thread-local state.
     */
    class PageEvictionerSelectorRANDOMXORWow : public PageEvictionerSelector {
    public:
        /*!\fn      PageEvictionerSelectorRANDOMXORWow(const BufferPool* bufferPool)
         * \brief   Constructs a _RANDOM_ buffer frame selector
         *
         * @param bufferPool The buffer pool this _RANDOM_ buffer frame selector is responsible for.
         */
        explicit PageEvictionerSelectorRANDOMXORWow(const BufferPool* bufferPool) :
                PageEvictionerSelector(bufferPool) {};

        /*!\fn      select() noexcept
         * \brief   Selects a page to be evicted from the buffer pool
         * \details Selects a buffer frame randomly using a Xorwow pseudo-random number generator.
         *
         * @return The selected buffer frame.
         */
        inline bf_idx select() noexcept final {

            /*!\var     _seedInitialized
             * \brief   Whether the state of the Xorshift is initialized on this thread
             * \details The first time \link select() \endlink runs on a particular thread, the state of the Xorshift
             *          needs to be initialized. If this is set on a thread, the state is already initialized on this
             *          thread.
             */
            static thread_local bool _seedInitialized;

            /*!\var     _x
             * \brief   The state of the Xorshift
             */
            static thread_local uint32_t _x;

            /*!\var     _y
             * \brief   The state of the Xorshift
             */
            static thread_local uint32_t _y;

            /*!\var     _z
             * \brief   The state of the Xorshift
             */
            static thread_local uint32_t _z;

            /*!\var     _w
             * \brief   The state of the Xorshift
             */
            static thread_local uint32_t _w;

            /*!\var     _v
             * \brief   The state of the Xorshift
             */
            static thread_local uint32_t _v;

            /*!\var     _d
             * \brief   The state of the Xorshift
             */
            static thread_local uint32_t _d;

            if (!_seedInitialized) {
                _x = std::random_device{}();
                _y = std::random_device{}();
                _z = std::random_device{}();
                _w = std::random_device{}();
                _v = std::random_device{}();
                _d = std::random_device{}();
                _seedInitialized = true;
            }
            uint32_t t = _x ^ (_x >> 2);
            _x = _y;
            _y = _z;
            _z = _w;
            _w = _v;
            _v = (_v ^ (_v << 4)) ^ (t ^ (t << 1));

            return (((_d += 362437) + _v) % (_maxBufferpoolIndex - 1) + 1);
        };

        /*!\fn      updateOnPageHit(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics on page hit
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink on which a page hit occurred.
         */
        inline void updateOnPageHit(bf_idx idx) noexcept final {};

        /*!\fn      updateOnPageUnfix(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics on page unfix
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink on which a page unfix occurred.
         */
        inline void updateOnPageUnfix(bf_idx idx) noexcept final {};

        /*!\fn      updateOnPageMiss(bf_idx idx, PageID pid) noexcept
         * \brief   Updates the eviction statistics on page miss
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink on which a page miss occurred.
         * @param pid The \link PageID \endlink of the \link generic_page \endlink that was loaded into the buffer
         *             frame with index \c idx .
         */
        inline void updateOnPageMiss(bf_idx idx, PageID pid) noexcept final {};

        /*!\fn      updateOnPageFixed(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics of fixed (i.e. used) pages during eviction
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink that was picked for eviction while the
         *            corresponding frame was fixed.
         */
        inline void updateOnPageFixed(bf_idx idx) noexcept final {};

        /*!\fn      updateOnPageDirty(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics of dirty pages during eviction
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink that was picked for eviction while the
         *            corresponding frame contained a dirty page.
         */
        inline void updateOnPageDirty(bf_idx idx) noexcept final {};

        /*!\fn      updateOnPageBlocked(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics of pages that cannot be evicted at all
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink which corresponding frame contains a page
         *            that cannot be evicted at all.
         */
        inline void updateOnPageBlocked(bf_idx idx) noexcept final {};

        /*!\fn      updateOnPageSwizzled(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics of pages containing swizzled pointers during eviction
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink that was picked for eviction while the
         *            corresponding frame contained a page with swizzled pointers.
         */
        inline void updateOnPageSwizzled(bf_idx idx) noexcept final {};

        /*!\fn      updateOnPageExplicitlyUnbuffered(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics on explicit unbuffer
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink whose corresponding frame is freed
         *            explicitly.
         */
        inline void updateOnPageExplicitlyUnbuffered(bf_idx idx) noexcept final {};

        /*!\fn      releaseInternalLatches() noexcept
         * \brief   Releases the internal latches of this buffer frame selector
         * \details This buffer frame selector does not use locking and therefore this function does nothing.
         */
        inline void releaseInternalLatches() noexcept final {};

    };

    /*!\class   PageEvictionerSelectorRANDOMXORShift128Plus
     * \brief   _RANDOM_ buffer frame selector
     * \details This is a buffer frame selector for the _Select-and-Filter_ page evictioner that implements the _RANDOM_
     *          policy. The _RANDOM_ policy selects buffer frames randomly. This version of the _RANDOM_ policy uses
     *          uses a Xorshift+ pseudo-random number generator and a 128-bit thread-local state.
     */
    class PageEvictionerSelectorRANDOMXORShift128Plus : public PageEvictionerSelector {
    public:
        /*!\fn      PageEvictionerSelectorRANDOMXORShift128Plus(const BufferPool* bufferPool)
         * \brief   Constructs a _RANDOM_ buffer frame selector
         *
         * @param bufferPool The buffer pool this _RANDOM_ buffer frame selector is responsible for.
         */
        explicit PageEvictionerSelectorRANDOMXORShift128Plus(const BufferPool* bufferPool) :
                PageEvictionerSelector(bufferPool) {};

        /*!\fn      select() noexcept
         * \brief   Selects a page to be evicted from the buffer pool
         * \details Selects a buffer frame randomly using a Xorshift+ pseudo-random number generator.
         *
         * @return The selected buffer frame.
         */
        inline bf_idx select() noexcept final {

            /*!\var     _seedInitialized
             * \brief   Whether the state of the Xorshift is initialized on this thread
             * \details The first time \link select() \endlink runs on a particular thread, the state of the Xorshift
             *          needs to be initialized. If this is set on a thread, the state is already initialized on this
             *          thread.
             */
            static thread_local bool _seedInitialized;

            /*!\var     _seed0
             * \brief   The state of the Xorshift
             */
            static thread_local uint64_t _seed0;

            /*!\var     _seed1
             * \brief   The state of the Xorshift
             */
            static thread_local uint64_t _seed1;

            if (!_seedInitialized) {
                _seed0 = std::random_device{}();
                _seed1 = std::random_device{}();
                _seedInitialized = true;
            }
            uint64_t x = _seed0;
            uint64_t const y = _seed1;
            _seed0 = y;
            x ^= x << 23;
            _seed1 = x ^ y ^ (x >> 17) ^ (y >> 26);
            return ((_seed1 + y) % (_maxBufferpoolIndex - 1) + 1);
        };

        /*!\fn      updateOnPageHit(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics on page hit
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink on which a page hit occurred.
         */
        inline void updateOnPageHit(bf_idx idx) noexcept final {};

        /*!\fn      updateOnPageUnfix(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics on page unfix
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink on which a page unfix occurred.
         */
        inline void updateOnPageUnfix(bf_idx idx) noexcept final {};

        /*!\fn      updateOnPageMiss(bf_idx idx, PageID pid) noexcept
         * \brief   Updates the eviction statistics on page miss
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink on which a page miss occurred.
         * @param pid The \link PageID \endlink of the \link generic_page \endlink that was loaded into the buffer
         *             frame with index \c idx .
         */
        inline void updateOnPageMiss(bf_idx idx, PageID pid) noexcept final {};

        /*!\fn      updateOnPageFixed(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics of fixed (i.e. used) pages during eviction
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink that was picked for eviction while the
         *            corresponding frame was fixed.
         */
        inline void updateOnPageFixed(bf_idx idx) noexcept final {};

        /*!\fn      updateOnPageDirty(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics of dirty pages during eviction
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink that was picked for eviction while the
         *            corresponding frame contained a dirty page.
         */
        inline void updateOnPageDirty(bf_idx idx) noexcept final {};

        /*!\fn      updateOnPageBlocked(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics of pages that cannot be evicted at all
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink which corresponding frame contains a page
         *            that cannot be evicted at all.
         */
        inline void updateOnPageBlocked(bf_idx idx) noexcept final {};

        /*!\fn      updateOnPageSwizzled(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics of pages containing swizzled pointers during eviction
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink that was picked for eviction while the
         *            corresponding frame contained a page with swizzled pointers.
         */
        inline void updateOnPageSwizzled(bf_idx idx) noexcept final {};

        /*!\fn      updateOnPageExplicitlyUnbuffered(bf_idx idx) noexcept
         * \brief   Updates the eviction statistics on explicit unbuffer
         * \details This buffer frame selector does not require any statistics and therefore this function does nothing.
         *
         * @param idx The buffer frame index of the \link BufferPool \endlink whose corresponding frame is freed
         *            explicitly.
         */
        inline void updateOnPageExplicitlyUnbuffered(bf_idx idx) noexcept final {};

        /*!\fn      releaseInternalLatches() noexcept
         * \brief   Releases the internal latches of this buffer frame selector
         * \details This buffer frame selector does not use locking and therefore this function does nothing.
         */
        inline void releaseInternalLatches() noexcept final {};

    };

} // zero::buffer_pool

#endif // __PAGE_EVICTIONER_SELECTOR_RANDOM_HPP
